"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stablelib+hmac@1.0.1";
exports.ids = ["vendor-chunks/@stablelib+hmac@1.0.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@stablelib+hmac@1.0.1/node_modules/@stablelib/hmac/lib/hmac.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@stablelib+hmac@1.0.1/node_modules/@stablelib/hmac/lib/hmac.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Package hmac implements HMAC algorithm.\n */\nvar hash_1 = __webpack_require__(/*! @stablelib/hash */ \"(ssr)/../../node_modules/.pnpm/@stablelib+hash@1.0.1/node_modules/@stablelib/hash/lib/hash.js\");\nvar constant_time_1 = __webpack_require__(/*! @stablelib/constant-time */ \"(ssr)/../../node_modules/.pnpm/@stablelib+constant-time@1.0.1/node_modules/@stablelib/constant-time/lib/constant-time.js\");\nvar wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"(ssr)/../../node_modules/.pnpm/@stablelib+wipe@1.0.1/node_modules/@stablelib/wipe/lib/wipe.js\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\nvar HMAC = /** @class */ (function () {\n    /**\n     * Constructs a new HMAC with the given Hash and secret key.\n     */\n    function HMAC(hash, key) {\n        this._finished = false; // true if HMAC was finalized\n        // Initialize inner and outer hashes.\n        this._inner = new hash();\n        this._outer = new hash();\n        // Set block and digest sizes for this HMAC\n        // instance to values from the hash.\n        this.blockSize = this._outer.blockSize;\n        this.digestLength = this._outer.digestLength;\n        // Pad temporary stores a key (or its hash) padded with zeroes.\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            // If key is bigger than hash block size, it must be\n            // hashed and this hash is used as a key instead.\n            this._inner.update(key).finish(pad).clean();\n        }\n        else {\n            // Otherwise, copy the key into pad.\n            pad.set(key);\n        }\n        // Now two different keys are derived from padded key\n        // by xoring a different byte value to each.\n        // To make inner hash key, xor byte 0x36 into pad.\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        // Update inner hash with the result.\n        this._inner.update(pad);\n        // To make outer hash key, xor byte 0x5c into pad.\n        // But since we already xored 0x36 there, we must\n        // first undo this by xoring it again.\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        // Update outer hash with the result.\n        this._outer.update(pad);\n        // Save states of both hashes, so that we can quickly restore\n        // them later in reset() without the need to remember the actual\n        // key and perform this initialization again.\n        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n            this._innerKeyedState = this._inner.saveState();\n            this._outerKeyedState = this._outer.saveState();\n        }\n        // Clean pad.\n        wipe_1.wipe(pad);\n    }\n    /**\n     * Returns HMAC state to the state initialized with key\n     * to make it possible to run HMAC over the other data with the same\n     * key without creating a new instance.\n     */\n    HMAC.prototype.reset = function () {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n        }\n        // Restore keyed states of inner and outer hashes.\n        this._inner.restoreState(this._innerKeyedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    /**\n     * Cleans HMAC state.\n     */\n    HMAC.prototype.clean = function () {\n        if (hash_1.isSerializableHash(this._inner)) {\n            this._inner.cleanSavedState(this._innerKeyedState);\n        }\n        if (hash_1.isSerializableHash(this._outer)) {\n            this._outer.cleanSavedState(this._outerKeyedState);\n        }\n        this._inner.clean();\n        this._outer.clean();\n    };\n    /**\n     * Updates state with provided data.\n     */\n    HMAC.prototype.update = function (data) {\n        this._inner.update(data);\n        return this;\n    };\n    /**\n     * Finalizes HMAC and puts the result in out.\n     */\n    HMAC.prototype.finish = function (out) {\n        if (this._finished) {\n            // If HMAC was finalized, outer hash is also finalized,\n            // so it produces the same digest it produced when it\n            // was finalized.\n            this._outer.finish(out);\n            return this;\n        }\n        // Finalize inner hash and store the result temporarily.\n        this._inner.finish(out);\n        // Update outer hash with digest of inner hash and and finalize it.\n        this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n        this._finished = true;\n        return this;\n    };\n    /**\n     * Returns the computed message authentication code.\n     */\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    /**\n     * Saves HMAC state.\n     * This function is needed for PBKDF2 optimization.\n     */\n    HMAC.prototype.saveState = function () {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n        }\n        return this._inner.saveState();\n    };\n    HMAC.prototype.restoreState = function (savedState) {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n        }\n        this._inner.restoreState(savedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    HMAC.prototype.cleanSavedState = function (savedState) {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n        }\n        this._inner.cleanSavedState(savedState);\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\nfunction hmac(hash, key, data) {\n    var h = new HMAC(hash, key);\n    h.update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\nexports.equal = constant_time_1.equal;\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzdGFibGVsaWIraG1hY0AxLjAuMS9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9obWFjL2xpYi9obWFjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0hBQWlCO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLDBKQUEwQjtBQUN4RCxhQUFhLG1CQUFPLENBQUMsc0hBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZvaWwvYXBwLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac3RhYmxlbGliK2htYWNAMS4wLjEvbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvaG1hYy9saWIvaG1hYy5qcz8xN2M1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIGhtYWMgaW1wbGVtZW50cyBITUFDIGFsZ29yaXRobS5cbiAqL1xudmFyIGhhc2hfMSA9IHJlcXVpcmUoXCJAc3RhYmxlbGliL2hhc2hcIik7XG52YXIgY29uc3RhbnRfdGltZV8xID0gcmVxdWlyZShcIkBzdGFibGVsaWIvY29uc3RhbnQtdGltZVwiKTtcbnZhciB3aXBlXzEgPSByZXF1aXJlKFwiQHN0YWJsZWxpYi93aXBlXCIpO1xuLyoqXG4gKiAgSE1BQyBpbXBsZW1lbnRzIGhhc2gtYmFzZWQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBhbGdvcml0aG0uXG4gKi9cbnZhciBITUFDID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgSE1BQyB3aXRoIHRoZSBnaXZlbiBIYXNoIGFuZCBzZWNyZXQga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhNQUMoaGFzaCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7IC8vIHRydWUgaWYgSE1BQyB3YXMgZmluYWxpemVkXG4gICAgICAgIC8vIEluaXRpYWxpemUgaW5uZXIgYW5kIG91dGVyIGhhc2hlcy5cbiAgICAgICAgdGhpcy5faW5uZXIgPSBuZXcgaGFzaCgpO1xuICAgICAgICB0aGlzLl9vdXRlciA9IG5ldyBoYXNoKCk7XG4gICAgICAgIC8vIFNldCBibG9jayBhbmQgZGlnZXN0IHNpemVzIGZvciB0aGlzIEhNQUNcbiAgICAgICAgLy8gaW5zdGFuY2UgdG8gdmFsdWVzIGZyb20gdGhlIGhhc2guXG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gdGhpcy5fb3V0ZXIuYmxvY2tTaXplO1xuICAgICAgICB0aGlzLmRpZ2VzdExlbmd0aCA9IHRoaXMuX291dGVyLmRpZ2VzdExlbmd0aDtcbiAgICAgICAgLy8gUGFkIHRlbXBvcmFyeSBzdG9yZXMgYSBrZXkgKG9yIGl0cyBoYXNoKSBwYWRkZWQgd2l0aCB6ZXJvZXMuXG4gICAgICAgIHZhciBwYWQgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICAgIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgIC8vIElmIGtleSBpcyBiaWdnZXIgdGhhbiBoYXNoIGJsb2NrIHNpemUsIGl0IG11c3QgYmVcbiAgICAgICAgICAgIC8vIGhhc2hlZCBhbmQgdGhpcyBoYXNoIGlzIHVzZWQgYXMgYSBrZXkgaW5zdGVhZC5cbiAgICAgICAgICAgIHRoaXMuX2lubmVyLnVwZGF0ZShrZXkpLmZpbmlzaChwYWQpLmNsZWFuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNvcHkgdGhlIGtleSBpbnRvIHBhZC5cbiAgICAgICAgICAgIHBhZC5zZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgdHdvIGRpZmZlcmVudCBrZXlzIGFyZSBkZXJpdmVkIGZyb20gcGFkZGVkIGtleVxuICAgICAgICAvLyBieSB4b3JpbmcgYSBkaWZmZXJlbnQgYnl0ZSB2YWx1ZSB0byBlYWNoLlxuICAgICAgICAvLyBUbyBtYWtlIGlubmVyIGhhc2gga2V5LCB4b3IgYnl0ZSAweDM2IGludG8gcGFkLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGlubmVyIGhhc2ggd2l0aCB0aGUgcmVzdWx0LlxuICAgICAgICB0aGlzLl9pbm5lci51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gVG8gbWFrZSBvdXRlciBoYXNoIGtleSwgeG9yIGJ5dGUgMHg1YyBpbnRvIHBhZC5cbiAgICAgICAgLy8gQnV0IHNpbmNlIHdlIGFscmVhZHkgeG9yZWQgMHgzNiB0aGVyZSwgd2UgbXVzdFxuICAgICAgICAvLyBmaXJzdCB1bmRvIHRoaXMgYnkgeG9yaW5nIGl0IGFnYWluLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBvdXRlciBoYXNoIHdpdGggdGhlIHJlc3VsdC5cbiAgICAgICAgdGhpcy5fb3V0ZXIudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIFNhdmUgc3RhdGVzIG9mIGJvdGggaGFzaGVzLCBzbyB0aGF0IHdlIGNhbiBxdWlja2x5IHJlc3RvcmVcbiAgICAgICAgLy8gdGhlbSBsYXRlciBpbiByZXNldCgpIHdpdGhvdXQgdGhlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIGFjdHVhbFxuICAgICAgICAvLyBrZXkgYW5kIHBlcmZvcm0gdGhpcyBpbml0aWFsaXphdGlvbiBhZ2Fpbi5cbiAgICAgICAgaWYgKGhhc2hfMS5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5faW5uZXIpICYmIGhhc2hfMS5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5fb3V0ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbm5lcktleWVkU3RhdGUgPSB0aGlzLl9pbm5lci5zYXZlU3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX291dGVyS2V5ZWRTdGF0ZSA9IHRoaXMuX291dGVyLnNhdmVTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFuIHBhZC5cbiAgICAgICAgd2lwZV8xLndpcGUocGFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBITUFDIHN0YXRlIHRvIHRoZSBzdGF0ZSBpbml0aWFsaXplZCB3aXRoIGtleVxuICAgICAqIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gcnVuIEhNQUMgb3ZlciB0aGUgb3RoZXIgZGF0YSB3aXRoIHRoZSBzYW1lXG4gICAgICoga2V5IHdpdGhvdXQgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2UuXG4gICAgICovXG4gICAgSE1BQy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaGFzaF8xLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikgfHwgIWhhc2hfMS5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5fb3V0ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJobWFjOiBjYW4ndCByZXNldCgpIGJlY2F1c2UgaGFzaCBkb2Vzbid0IGltcGxlbWVudCByZXN0b3JlU3RhdGUoKVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0b3JlIGtleWVkIHN0YXRlcyBvZiBpbm5lciBhbmQgb3V0ZXIgaGFzaGVzLlxuICAgICAgICB0aGlzLl9pbm5lci5yZXN0b3JlU3RhdGUodGhpcy5faW5uZXJLZXllZFN0YXRlKTtcbiAgICAgICAgdGhpcy5fb3V0ZXIucmVzdG9yZVN0YXRlKHRoaXMuX291dGVyS2V5ZWRTdGF0ZSk7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIEhNQUMgc3RhdGUuXG4gICAgICovXG4gICAgSE1BQy5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChoYXNoXzEuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSkge1xuICAgICAgICAgICAgdGhpcy5faW5uZXIuY2xlYW5TYXZlZFN0YXRlKHRoaXMuX2lubmVyS2V5ZWRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc2hfMS5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5fb3V0ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdXRlci5jbGVhblNhdmVkU3RhdGUodGhpcy5fb3V0ZXJLZXllZFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbm5lci5jbGVhbigpO1xuICAgICAgICB0aGlzLl9vdXRlci5jbGVhbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzdGF0ZSB3aXRoIHByb3ZpZGVkIGRhdGEuXG4gICAgICovXG4gICAgSE1BQy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5faW5uZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmFsaXplcyBITUFDIGFuZCBwdXRzIHRoZSByZXN1bHQgaW4gb3V0LlxuICAgICAqL1xuICAgIEhNQUMucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAvLyBJZiBITUFDIHdhcyBmaW5hbGl6ZWQsIG91dGVyIGhhc2ggaXMgYWxzbyBmaW5hbGl6ZWQsXG4gICAgICAgICAgICAvLyBzbyBpdCBwcm9kdWNlcyB0aGUgc2FtZSBkaWdlc3QgaXQgcHJvZHVjZWQgd2hlbiBpdFxuICAgICAgICAgICAgLy8gd2FzIGZpbmFsaXplZC5cbiAgICAgICAgICAgIHRoaXMuX291dGVyLmZpbmlzaChvdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluYWxpemUgaW5uZXIgaGFzaCBhbmQgc3RvcmUgdGhlIHJlc3VsdCB0ZW1wb3JhcmlseS5cbiAgICAgICAgdGhpcy5faW5uZXIuZmluaXNoKG91dCk7XG4gICAgICAgIC8vIFVwZGF0ZSBvdXRlciBoYXNoIHdpdGggZGlnZXN0IG9mIGlubmVyIGhhc2ggYW5kIGFuZCBmaW5hbGl6ZSBpdC5cbiAgICAgICAgdGhpcy5fb3V0ZXIudXBkYXRlKG91dC5zdWJhcnJheSgwLCB0aGlzLmRpZ2VzdExlbmd0aCkpLmZpbmlzaChvdXQpO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICAgICAqL1xuICAgIEhNQUMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGlnZXN0TGVuZ3RoKTtcbiAgICAgICAgdGhpcy5maW5pc2gob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIEhNQUMgc3RhdGUuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBuZWVkZWQgZm9yIFBCS0RGMiBvcHRpbWl6YXRpb24uXG4gICAgICovXG4gICAgSE1BQy5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWhhc2hfMS5pc1NlcmlhbGl6YWJsZUhhc2godGhpcy5faW5uZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJobWFjOiBjYW4ndCBzYXZlU3RhdGUoKSBiZWNhdXNlIGhhc2ggZG9lc24ndCBpbXBsZW1lbnQgaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLnNhdmVTdGF0ZSgpO1xuICAgIH07XG4gICAgSE1BQy5wcm90b3R5cGUucmVzdG9yZVN0YXRlID0gZnVuY3Rpb24gKHNhdmVkU3RhdGUpIHtcbiAgICAgICAgaWYgKCFoYXNoXzEuaXNTZXJpYWxpemFibGVIYXNoKHRoaXMuX2lubmVyKSB8fCAhaGFzaF8xLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9vdXRlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImhtYWM6IGNhbid0IHJlc3RvcmVTdGF0ZSgpIGJlY2F1c2UgaGFzaCBkb2Vzbid0IGltcGxlbWVudCBpdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbm5lci5yZXN0b3JlU3RhdGUoc2F2ZWRTdGF0ZSk7XG4gICAgICAgIHRoaXMuX291dGVyLnJlc3RvcmVTdGF0ZSh0aGlzLl9vdXRlcktleWVkU3RhdGUpO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEhNQUMucHJvdG90eXBlLmNsZWFuU2F2ZWRTdGF0ZSA9IGZ1bmN0aW9uIChzYXZlZFN0YXRlKSB7XG4gICAgICAgIGlmICghaGFzaF8xLmlzU2VyaWFsaXphYmxlSGFzaCh0aGlzLl9pbm5lcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImhtYWM6IGNhbid0IGNsZWFuU2F2ZWRTdGF0ZSgpIGJlY2F1c2UgaGFzaCBkb2Vzbid0IGltcGxlbWVudCBpdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbm5lci5jbGVhblNhdmVkU3RhdGUoc2F2ZWRTdGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gSE1BQztcbn0oKSk7XG5leHBvcnRzLkhNQUMgPSBITUFDO1xuLyoqXG4gKiBSZXR1cm5zIEhNQUMgdXNpbmcgdGhlIGdpdmVuIGhhc2ggY29uc3RydWN0b3IgZm9yIHRoZSBrZXkgb3ZlciBkYXRhLlxuICovXG5mdW5jdGlvbiBobWFjKGhhc2gsIGtleSwgZGF0YSkge1xuICAgIHZhciBoID0gbmV3IEhNQUMoaGFzaCwga2V5KTtcbiAgICBoLnVwZGF0ZShkYXRhKTtcbiAgICB2YXIgZGlnZXN0ID0gaC5kaWdlc3QoKTtcbiAgICBoLmNsZWFuKCk7XG4gICAgcmV0dXJuIGRpZ2VzdDtcbn1cbmV4cG9ydHMuaG1hYyA9IGhtYWM7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0d28gSE1BQyBkaWdlc3RzIGFyZSBlcXVhbC5cbiAqIFVzZXMgY29uc3RhbnQtdGltZSBjb21wYXJpc29uIHRvIGF2b2lkIGxlYWtpbmcgdGltaW5nIGluZm9ybWF0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgY29uc3QgcmVjZWl2ZWREaWdlc3QgPSAuLi5cbiAqICAgIGNvbnN0IHJlYWxEaWdlc3QgPSBobWFjKFNIQTI1Niwga2V5LCBkYXRhKTtcbiAqICAgIGlmICghZXF1YWwocmVjZWl2ZWREaWdlc3QsIHJlYWxEaWdlc3QpKSB7XG4gKiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aGVudGljYXRpb24gZXJyb3JcIik7XG4gKiAgICB9XG4gKi9cbmV4cG9ydHMuZXF1YWwgPSBjb25zdGFudF90aW1lXzEuZXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@stablelib+hmac@1.0.1/node_modules/@stablelib/hmac/lib/hmac.js\n");

/***/ })

};
;