# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregateCategory {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
}

type AggregateCryptoPrices {
  _avg: CryptoPricesAvgAggregate
  _count: CryptoPricesCountAggregate
  _max: CryptoPricesMaxAggregate
  _min: CryptoPricesMinAggregate
  _sum: CryptoPricesSumAggregate
}

type AggregateMarket {
  _avg: MarketAvgAggregate
  _count: MarketCountAggregate
  _max: MarketMaxAggregate
  _min: MarketMinAggregate
  _sum: MarketSumAggregate
}

type AggregateMarketGroup {
  _avg: MarketGroupAvgAggregate
  _count: MarketGroupCountAggregate
  _max: MarketGroupMaxAggregate
  _min: MarketGroupMinAggregate
  _sum: MarketGroupSumAggregate
}

type AggregateMarketPrice {
  _avg: MarketPriceAvgAggregate
  _count: MarketPriceCountAggregate
  _max: MarketPriceMaxAggregate
  _min: MarketPriceMinAggregate
  _sum: MarketPriceSumAggregate
}

type AggregatePosition {
  _avg: PositionAvgAggregate
  _count: PositionCountAggregate
  _max: PositionMaxAggregate
  _min: PositionMinAggregate
  _sum: PositionSumAggregate
}

type AggregateResource {
  _avg: ResourceAvgAggregate
  _count: ResourceCountAggregate
  _max: ResourceMaxAggregate
  _min: ResourceMinAggregate
  _sum: ResourceSumAggregate
}

type AggregateResourcePrice {
  _avg: ResourcePriceAvgAggregate
  _count: ResourcePriceCountAggregate
  _max: ResourcePriceMaxAggregate
  _min: ResourcePriceMinAggregate
  _sum: ResourcePriceSumAggregate
}

type AggregateTransaction {
  _avg: TransactionAvgAggregate
  _count: TransactionCountAggregate
  _max: TransactionMaxAggregate
  _min: TransactionMinAggregate
  _sum: TransactionSumAggregate
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

input BigIntFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntFilter
  notIn: [BigInt!]
}

input BigIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedBigIntFilter
  _min: NestedBigIntFilter
  _sum: NestedBigIntFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntWithAggregatesFilter
  notIn: [BigInt!]
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input BoolNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBoolNullableFilter
  _min: NestedBoolNullableFilter
  equals: Boolean
  not: NestedBoolNullableWithAggregatesFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type CandleAndTimestampType {
  data: [CandleType!]!
  lastUpdateTimestamp: Int!
}

type CandleType {
  close: String!
  high: String!
  low: String!
  open: String!
  timestamp: Int!
}

type Category {
  _count: CategoryCount
  createdAt: DateTimeISO!
  id: Int!
  marketGroups(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): [MarketGroup!]!
  name: String!
  resources(cursor: ResourceWhereUniqueInput, distinct: [ResourceScalarFieldEnum!], orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): [Resource!]!
  slug: String!
}

type CategoryAvgAggregate {
  id: Float
}

input CategoryAvgOrderByAggregateInput {
  id: SortOrder
}

type CategoryCount {
  market_group(where: MarketGroupWhereInput): Int!
  resource(where: ResourceWhereInput): Int!
}

type CategoryCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  slug: Int!
}

input CategoryCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type CategoryGroupBy {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
  createdAt: DateTimeISO!
  id: Int!
  name: String!
  slug: String!
}

type CategoryMaxAggregate {
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input CategoryMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type CategoryMinAggregate {
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input CategoryMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input CategoryNullableRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

input CategoryOrderByWithAggregationInput {
  _avg: CategoryAvgOrderByAggregateInput
  _count: CategoryCountOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  _sum: CategorySumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input CategoryOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  marketGroups: MarketGroupOrderByRelationAggregateInput
  name: SortOrder
  resources: ResourceOrderByRelationAggregateInput
  slug: SortOrder
}

enum CategoryScalarFieldEnum {
  createdAt
  id
  name
  slug
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  slug: StringWithAggregatesFilter
}

type CategorySumAggregate {
  id: Int
}

input CategorySumOrderByAggregateInput {
  id: SortOrder
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  marketGroups: MarketGroupListRelationFilter
  name: StringFilter
  resources: ResourceListRelationFilter
  slug: StringFilter
}

input CategoryWhereUniqueInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  createdAt: DateTimeFilter
  id: Int
  marketGroups: MarketGroupListRelationFilter
  name: String
  resources: ResourceListRelationFilter
  slug: String
}

type CollateralTransfer {
  collateral: Decimal!
  createdAt: DateTimeISO!
  id: Int!
  owner: String!
  timestamp: Int!
  transaction(where: TransactionWhereInput): Transaction
  transactionHash: String!
}

input CollateralTransferNullableRelationFilter {
  is: CollateralTransferWhereInput
  isNot: CollateralTransferWhereInput
}

input CollateralTransferOrderByWithRelationInput {
  collateral: SortOrder
  createdAt: SortOrder
  id: SortOrder
  owner: SortOrder
  timestamp: SortOrder
  transaction: TransactionOrderByWithRelationInput
  transactionHash: SortOrder
}

input CollateralTransferWhereInput {
  AND: [CollateralTransferWhereInput!]
  NOT: [CollateralTransferWhereInput!]
  OR: [CollateralTransferWhereInput!]
  collateral: DecimalFilter
  createdAt: DateTimeFilter
  id: IntFilter
  owner: StringFilter
  timestamp: IntFilter
  transaction: TransactionNullableRelationFilter
  transactionHash: StringFilter
}

type CryptoPrices {
  id: Int!
  price: Float!
  ticker: String
  timestamp: DateTimeISO!
}

type CryptoPricesAvgAggregate {
  id: Float
  price: Float
}

input CryptoPricesAvgOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
}

type CryptoPricesCountAggregate {
  _all: Int!
  id: Int!
  price: Int!
  ticker: Int!
  timestamp: Int!
}

input CryptoPricesCountOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
  ticker: SortOrder
  timestamp: SortOrder
}

type CryptoPricesGroupBy {
  _avg: CryptoPricesAvgAggregate
  _count: CryptoPricesCountAggregate
  _max: CryptoPricesMaxAggregate
  _min: CryptoPricesMinAggregate
  _sum: CryptoPricesSumAggregate
  id: Int!
  price: Float!
  ticker: String
  timestamp: DateTimeISO!
}

type CryptoPricesMaxAggregate {
  id: Int
  price: Float
  ticker: String
  timestamp: DateTimeISO
}

input CryptoPricesMaxOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
  ticker: SortOrder
  timestamp: SortOrder
}

type CryptoPricesMinAggregate {
  id: Int
  price: Float
  ticker: String
  timestamp: DateTimeISO
}

input CryptoPricesMinOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
  ticker: SortOrder
  timestamp: SortOrder
}

input CryptoPricesOrderByWithAggregationInput {
  _avg: CryptoPricesAvgOrderByAggregateInput
  _count: CryptoPricesCountOrderByAggregateInput
  _max: CryptoPricesMaxOrderByAggregateInput
  _min: CryptoPricesMinOrderByAggregateInput
  _sum: CryptoPricesSumOrderByAggregateInput
  id: SortOrder
  price: SortOrder
  ticker: SortOrderInput
  timestamp: SortOrder
}

input CryptoPricesOrderByWithRelationInput {
  id: SortOrder
  price: SortOrder
  ticker: SortOrderInput
  timestamp: SortOrder
}

enum CryptoPricesScalarFieldEnum {
  id
  price
  ticker
  timestamp
}

input CryptoPricesScalarWhereWithAggregatesInput {
  AND: [CryptoPricesScalarWhereWithAggregatesInput!]
  NOT: [CryptoPricesScalarWhereWithAggregatesInput!]
  OR: [CryptoPricesScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  price: FloatWithAggregatesFilter
  ticker: StringNullableWithAggregatesFilter
  timestamp: DateTimeWithAggregatesFilter
}

type CryptoPricesSumAggregate {
  id: Int
  price: Float
}

input CryptoPricesSumOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
}

input CryptoPricesWhereInput {
  AND: [CryptoPricesWhereInput!]
  NOT: [CryptoPricesWhereInput!]
  OR: [CryptoPricesWhereInput!]
  id: IntFilter
  price: FloatFilter
  ticker: StringNullableFilter
  timestamp: DateTimeFilter
}

input CryptoPricesWhereUniqueInput {
  AND: [CryptoPricesWhereInput!]
  NOT: [CryptoPricesWhereInput!]
  OR: [CryptoPricesWhereInput!]
  id: Int
  price: FloatFilter
  ticker: StringNullableFilter
  timestamp: DateTimeFilter
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input DecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input DecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input DecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input Enumtransaction_type_enumFilter {
  equals: transaction_type_enum
  in: [transaction_type_enum!]
  not: NestedEnumtransaction_type_enumFilter
  notIn: [transaction_type_enum!]
}

input Enumtransaction_type_enumWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumtransaction_type_enumFilter
  _min: NestedEnumtransaction_type_enumFilter
  equals: transaction_type_enum
  in: [transaction_type_enum!]
  not: NestedEnumtransaction_type_enumWithAggregatesFilter
  notIn: [transaction_type_enum!]
}

type Event {
  blockNumber: Int!
  createdAt: DateTimeISO!
  id: Int!
  logData: JSON!
  logIndex: Int!
  marketGroup(where: MarketGroupWhereInput): MarketGroup
  marketGroupId: Int
  timestamp: BigInt!
  transaction(where: TransactionWhereInput): Transaction
  transactionHash: String!
}

input EventListRelationFilter {
  every: EventWhereInput
  none: EventWhereInput
  some: EventWhereInput
}

input EventNullableRelationFilter {
  is: EventWhereInput
  isNot: EventWhereInput
}

input EventOrderByRelationAggregateInput {
  _count: SortOrder
}

input EventOrderByWithRelationInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  id: SortOrder
  logData: SortOrder
  logIndex: SortOrder
  marketGroup: MarketGroupOrderByWithRelationInput
  marketGroupId: SortOrderInput
  timestamp: SortOrder
  transaction: TransactionOrderByWithRelationInput
  transactionHash: SortOrder
}

enum EventScalarFieldEnum {
  blockNumber
  createdAt
  id
  logData
  logIndex
  marketGroupId
  timestamp
  transactionHash
}

input EventTransactionHashMarketGroupIdBlockNumberLogIndexCompoundUniqueInput {
  blockNumber: Int!
  logIndex: Int!
  marketGroupId: Int!
  transactionHash: String!
}

input EventWhereInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  blockNumber: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  logData: JsonFilter
  logIndex: IntFilter
  marketGroup: MarketGroupNullableRelationFilter
  marketGroupId: IntNullableFilter
  timestamp: BigIntFilter
  transaction: TransactionNullableRelationFilter
  transactionHash: StringFilter
}

input EventWhereUniqueInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  blockNumber: IntFilter
  createdAt: DateTimeFilter
  id: Int
  logData: JsonFilter
  logIndex: IntFilter
  marketGroup: MarketGroupNullableRelationFilter
  marketGroupId: IntNullableFilter
  timestamp: BigIntFilter
  transaction: TransactionNullableRelationFilter
  transactionHash: StringFilter
  transactionHash_marketGroupId_blockNumber_logIndex: EventTransactionHashMarketGroupIdBlockNumberLogIndexCompoundUniqueInput
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Market {
  _count: MarketCount
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  createdAt: DateTimeISO!
  endTimestamp: Int
  id: Int!
  marketGroup(where: MarketGroupWhereInput): MarketGroup
  marketGroupId: Int
  marketId: Int!
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsClaimstatementNo: String
  marketParamsClaimstatementYesOrNumeric: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  maxPriceD18: Decimal
  minPriceD18: Decimal
  optionName: String
  poolAddress: String
  positions(cursor: PositionWhereUniqueInput, distinct: [PositionScalarFieldEnum!], orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): [Position!]!
  public: Boolean!
  question: String
  rules: String
  settled: Boolean
  settlementPriceD18: Decimal
  startTimestamp: Int
  startingSqrtPriceX96: String
}

type MarketAvgAggregate {
  baseAssetMaxPriceTick: Float
  baseAssetMinPriceTick: Float
  endTimestamp: Float
  id: Float
  marketGroupId: Float
  marketId: Float
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsFeerate: Float
  maxPriceD18: Decimal
  minPriceD18: Decimal
  settlementPriceD18: Decimal
  startTimestamp: Float
}

input MarketAvgOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsFeerate: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  settlementPriceD18: SortOrder
  startTimestamp: SortOrder
}

type MarketCount {
  position(where: PositionWhereInput): Int!
}

type MarketCountAggregate {
  _all: Int!
  baseAssetMaxPriceTick: Int!
  baseAssetMinPriceTick: Int!
  createdAt: Int!
  endTimestamp: Int!
  id: Int!
  marketGroupId: Int!
  marketId: Int!
  marketParamsAssertionliveness: Int!
  marketParamsBondamount: Int!
  marketParamsBondcurrency: Int!
  marketParamsClaimstatementNo: Int!
  marketParamsClaimstatementYesOrNumeric: Int!
  marketParamsFeerate: Int!
  marketParamsOptimisticoraclev3: Int!
  marketParamsUniswappositionmanager: Int!
  marketParamsUniswapquoter: Int!
  marketParamsUniswapswaprouter: Int!
  maxPriceD18: Int!
  minPriceD18: Int!
  optionName: Int!
  poolAddress: Int!
  public: Int!
  question: Int!
  rules: Int!
  settled: Int!
  settlementPriceD18: Int!
  startTimestamp: Int!
  startingSqrtPriceX96: Int!
}

input MarketCountOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  createdAt: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsClaimstatementNo: SortOrder
  marketParamsClaimstatementYesOrNumeric: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  optionName: SortOrder
  poolAddress: SortOrder
  public: SortOrder
  question: SortOrder
  rules: SortOrder
  settled: SortOrder
  settlementPriceD18: SortOrder
  startTimestamp: SortOrder
  startingSqrtPriceX96: SortOrder
}

type MarketGroup {
  _count: MarketGroupCount
  address: String
  baseTokenName: String
  category(where: CategoryWhereInput): Category
  categoryId: Int
  chainId: Int!
  collateralAsset: String
  collateralDecimals: Int
  collateralSymbol: String
  createdAt: DateTimeISO!
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  events(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): [Event!]!
  factoryAddress: String
  id: Int!
  initializationNonce: String
  isBridged: Boolean!
  isCumulative: Boolean!
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsClaimstatementNo: String
  marketParamsClaimstatementYesOrNumeric: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  markets(cursor: MarketWhereUniqueInput, distinct: [MarketScalarFieldEnum!], orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): [Market!]!
  minTradeSize: Decimal
  owner: String
  question: String
  quoteTokenName: String
  resource(where: ResourceWhereInput): Resource
  resourceId: Int
}

input MarketGroupAddressChainIdCompoundUniqueInput {
  address: String!
  chainId: Int!
}

type MarketGroupAvgAggregate {
  categoryId: Float
  chainId: Float
  collateralDecimals: Float
  deployTimestamp: Float
  deployTxnBlockNumber: Float
  id: Float
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsFeerate: Float
  minTradeSize: Decimal
  resourceId: Float
}

input MarketGroupAvgOrderByAggregateInput {
  categoryId: SortOrder
  chainId: SortOrder
  collateralDecimals: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  id: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsFeerate: SortOrder
  minTradeSize: SortOrder
  resourceId: SortOrder
}

type MarketGroupBy {
  _avg: MarketAvgAggregate
  _count: MarketCountAggregate
  _max: MarketMaxAggregate
  _min: MarketMinAggregate
  _sum: MarketSumAggregate
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  createdAt: DateTimeISO!
  endTimestamp: Int
  id: Int!
  marketGroupId: Int
  marketId: Int!
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsClaimstatementNo: String
  marketParamsClaimstatementYesOrNumeric: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  maxPriceD18: Decimal
  minPriceD18: Decimal
  optionName: String
  poolAddress: String
  public: Boolean!
  question: String
  rules: String
  settled: Boolean
  settlementPriceD18: Decimal
  startTimestamp: Int
  startingSqrtPriceX96: String
}

type MarketGroupCount {
  event(where: EventWhereInput): Int!
  market(where: MarketWhereInput): Int!
}

type MarketGroupCountAggregate {
  _all: Int!
  address: Int!
  baseTokenName: Int!
  categoryId: Int!
  chainId: Int!
  collateralAsset: Int!
  collateralDecimals: Int!
  collateralSymbol: Int!
  createdAt: Int!
  deployTimestamp: Int!
  deployTxnBlockNumber: Int!
  factoryAddress: Int!
  id: Int!
  initializationNonce: Int!
  isBridged: Int!
  isCumulative: Int!
  marketParamsAssertionliveness: Int!
  marketParamsBondamount: Int!
  marketParamsBondcurrency: Int!
  marketParamsClaimstatementNo: Int!
  marketParamsClaimstatementYesOrNumeric: Int!
  marketParamsFeerate: Int!
  marketParamsOptimisticoraclev3: Int!
  marketParamsUniswappositionmanager: Int!
  marketParamsUniswapquoter: Int!
  marketParamsUniswapswaprouter: Int!
  minTradeSize: Int!
  owner: Int!
  question: Int!
  quoteTokenName: Int!
  resourceId: Int!
}

input MarketGroupCountOrderByAggregateInput {
  address: SortOrder
  baseTokenName: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  collateralAsset: SortOrder
  collateralDecimals: SortOrder
  collateralSymbol: SortOrder
  createdAt: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  factoryAddress: SortOrder
  id: SortOrder
  initializationNonce: SortOrder
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsClaimstatementNo: SortOrder
  marketParamsClaimstatementYesOrNumeric: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  minTradeSize: SortOrder
  owner: SortOrder
  question: SortOrder
  quoteTokenName: SortOrder
  resourceId: SortOrder
}

type MarketGroupGroupBy {
  _avg: MarketGroupAvgAggregate
  _count: MarketGroupCountAggregate
  _max: MarketGroupMaxAggregate
  _min: MarketGroupMinAggregate
  _sum: MarketGroupSumAggregate
  address: String
  baseTokenName: String
  categoryId: Int
  chainId: Int!
  collateralAsset: String
  collateralDecimals: Int
  collateralSymbol: String
  createdAt: DateTimeISO!
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  factoryAddress: String
  id: Int!
  initializationNonce: String
  isBridged: Boolean!
  isCumulative: Boolean!
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsClaimstatementNo: String
  marketParamsClaimstatementYesOrNumeric: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  minTradeSize: Decimal
  owner: String
  question: String
  quoteTokenName: String
  resourceId: Int
}

input MarketGroupListRelationFilter {
  every: MarketGroupWhereInput
  none: MarketGroupWhereInput
  some: MarketGroupWhereInput
}

type MarketGroupMaxAggregate {
  address: String
  baseTokenName: String
  categoryId: Int
  chainId: Int
  collateralAsset: String
  collateralDecimals: Int
  collateralSymbol: String
  createdAt: DateTimeISO
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  factoryAddress: String
  id: Int
  initializationNonce: String
  isBridged: Boolean
  isCumulative: Boolean
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsClaimstatementNo: String
  marketParamsClaimstatementYesOrNumeric: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  minTradeSize: Decimal
  owner: String
  question: String
  quoteTokenName: String
  resourceId: Int
}

input MarketGroupMaxOrderByAggregateInput {
  address: SortOrder
  baseTokenName: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  collateralAsset: SortOrder
  collateralDecimals: SortOrder
  collateralSymbol: SortOrder
  createdAt: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  factoryAddress: SortOrder
  id: SortOrder
  initializationNonce: SortOrder
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsClaimstatementNo: SortOrder
  marketParamsClaimstatementYesOrNumeric: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  minTradeSize: SortOrder
  owner: SortOrder
  question: SortOrder
  quoteTokenName: SortOrder
  resourceId: SortOrder
}

type MarketGroupMinAggregate {
  address: String
  baseTokenName: String
  categoryId: Int
  chainId: Int
  collateralAsset: String
  collateralDecimals: Int
  collateralSymbol: String
  createdAt: DateTimeISO
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  factoryAddress: String
  id: Int
  initializationNonce: String
  isBridged: Boolean
  isCumulative: Boolean
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsClaimstatementNo: String
  marketParamsClaimstatementYesOrNumeric: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  minTradeSize: Decimal
  owner: String
  question: String
  quoteTokenName: String
  resourceId: Int
}

input MarketGroupMinOrderByAggregateInput {
  address: SortOrder
  baseTokenName: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  collateralAsset: SortOrder
  collateralDecimals: SortOrder
  collateralSymbol: SortOrder
  createdAt: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  factoryAddress: SortOrder
  id: SortOrder
  initializationNonce: SortOrder
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsClaimstatementNo: SortOrder
  marketParamsClaimstatementYesOrNumeric: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  minTradeSize: SortOrder
  owner: SortOrder
  question: SortOrder
  quoteTokenName: SortOrder
  resourceId: SortOrder
}

input MarketGroupNullableRelationFilter {
  is: MarketGroupWhereInput
  isNot: MarketGroupWhereInput
}

input MarketGroupOrderByRelationAggregateInput {
  _count: SortOrder
}

input MarketGroupOrderByWithAggregationInput {
  _avg: MarketGroupAvgOrderByAggregateInput
  _count: MarketGroupCountOrderByAggregateInput
  _max: MarketGroupMaxOrderByAggregateInput
  _min: MarketGroupMinOrderByAggregateInput
  _sum: MarketGroupSumOrderByAggregateInput
  address: SortOrderInput
  baseTokenName: SortOrderInput
  categoryId: SortOrderInput
  chainId: SortOrder
  collateralAsset: SortOrderInput
  collateralDecimals: SortOrderInput
  collateralSymbol: SortOrderInput
  createdAt: SortOrder
  deployTimestamp: SortOrderInput
  deployTxnBlockNumber: SortOrderInput
  factoryAddress: SortOrderInput
  id: SortOrder
  initializationNonce: SortOrderInput
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrderInput
  marketParamsBondamount: SortOrderInput
  marketParamsBondcurrency: SortOrderInput
  marketParamsClaimstatementNo: SortOrderInput
  marketParamsClaimstatementYesOrNumeric: SortOrderInput
  marketParamsFeerate: SortOrderInput
  marketParamsOptimisticoraclev3: SortOrderInput
  marketParamsUniswappositionmanager: SortOrderInput
  marketParamsUniswapquoter: SortOrderInput
  marketParamsUniswapswaprouter: SortOrderInput
  minTradeSize: SortOrderInput
  owner: SortOrderInput
  question: SortOrderInput
  quoteTokenName: SortOrderInput
  resourceId: SortOrderInput
}

input MarketGroupOrderByWithRelationInput {
  address: SortOrderInput
  baseTokenName: SortOrderInput
  category: CategoryOrderByWithRelationInput
  categoryId: SortOrderInput
  chainId: SortOrder
  collateralAsset: SortOrderInput
  collateralDecimals: SortOrderInput
  collateralSymbol: SortOrderInput
  createdAt: SortOrder
  deployTimestamp: SortOrderInput
  deployTxnBlockNumber: SortOrderInput
  events: EventOrderByRelationAggregateInput
  factoryAddress: SortOrderInput
  id: SortOrder
  initializationNonce: SortOrderInput
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrderInput
  marketParamsBondamount: SortOrderInput
  marketParamsBondcurrency: SortOrderInput
  marketParamsClaimstatementNo: SortOrderInput
  marketParamsClaimstatementYesOrNumeric: SortOrderInput
  marketParamsFeerate: SortOrderInput
  marketParamsOptimisticoraclev3: SortOrderInput
  marketParamsUniswappositionmanager: SortOrderInput
  marketParamsUniswapquoter: SortOrderInput
  marketParamsUniswapswaprouter: SortOrderInput
  markets: MarketOrderByRelationAggregateInput
  minTradeSize: SortOrderInput
  owner: SortOrderInput
  question: SortOrderInput
  quoteTokenName: SortOrderInput
  resource: ResourceOrderByWithRelationInput
  resourceId: SortOrderInput
}

enum MarketGroupScalarFieldEnum {
  address
  baseTokenName
  categoryId
  chainId
  collateralAsset
  collateralDecimals
  collateralSymbol
  createdAt
  deployTimestamp
  deployTxnBlockNumber
  factoryAddress
  id
  initializationNonce
  isBridged
  isCumulative
  marketParamsAssertionliveness
  marketParamsBondamount
  marketParamsBondcurrency
  marketParamsClaimstatementNo
  marketParamsClaimstatementYesOrNumeric
  marketParamsFeerate
  marketParamsOptimisticoraclev3
  marketParamsUniswappositionmanager
  marketParamsUniswapquoter
  marketParamsUniswapswaprouter
  minTradeSize
  owner
  question
  quoteTokenName
  resourceId
}

input MarketGroupScalarWhereWithAggregatesInput {
  AND: [MarketGroupScalarWhereWithAggregatesInput!]
  NOT: [MarketGroupScalarWhereWithAggregatesInput!]
  OR: [MarketGroupScalarWhereWithAggregatesInput!]
  address: StringNullableWithAggregatesFilter
  baseTokenName: StringNullableWithAggregatesFilter
  categoryId: IntNullableWithAggregatesFilter
  chainId: IntWithAggregatesFilter
  collateralAsset: StringNullableWithAggregatesFilter
  collateralDecimals: IntNullableWithAggregatesFilter
  collateralSymbol: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  deployTimestamp: IntNullableWithAggregatesFilter
  deployTxnBlockNumber: IntNullableWithAggregatesFilter
  factoryAddress: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  initializationNonce: StringNullableWithAggregatesFilter
  isBridged: BoolWithAggregatesFilter
  isCumulative: BoolWithAggregatesFilter
  marketParamsAssertionliveness: DecimalNullableWithAggregatesFilter
  marketParamsBondamount: DecimalNullableWithAggregatesFilter
  marketParamsBondcurrency: StringNullableWithAggregatesFilter
  marketParamsClaimstatementNo: StringNullableWithAggregatesFilter
  marketParamsClaimstatementYesOrNumeric: StringNullableWithAggregatesFilter
  marketParamsFeerate: IntNullableWithAggregatesFilter
  marketParamsOptimisticoraclev3: StringNullableWithAggregatesFilter
  marketParamsUniswappositionmanager: StringNullableWithAggregatesFilter
  marketParamsUniswapquoter: StringNullableWithAggregatesFilter
  marketParamsUniswapswaprouter: StringNullableWithAggregatesFilter
  minTradeSize: DecimalNullableWithAggregatesFilter
  owner: StringNullableWithAggregatesFilter
  question: StringNullableWithAggregatesFilter
  quoteTokenName: StringNullableWithAggregatesFilter
  resourceId: IntNullableWithAggregatesFilter
}

type MarketGroupSumAggregate {
  categoryId: Int
  chainId: Int
  collateralDecimals: Int
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  id: Int
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsFeerate: Int
  minTradeSize: Decimal
  resourceId: Int
}

input MarketGroupSumOrderByAggregateInput {
  categoryId: SortOrder
  chainId: SortOrder
  collateralDecimals: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  id: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsFeerate: SortOrder
  minTradeSize: SortOrder
  resourceId: SortOrder
}

input MarketGroupWhereInput {
  AND: [MarketGroupWhereInput!]
  NOT: [MarketGroupWhereInput!]
  OR: [MarketGroupWhereInput!]
  address: StringNullableFilter
  baseTokenName: StringNullableFilter
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  chainId: IntFilter
  collateralAsset: StringNullableFilter
  collateralDecimals: IntNullableFilter
  collateralSymbol: StringNullableFilter
  createdAt: DateTimeFilter
  deployTimestamp: IntNullableFilter
  deployTxnBlockNumber: IntNullableFilter
  events: EventListRelationFilter
  factoryAddress: StringNullableFilter
  id: IntFilter
  initializationNonce: StringNullableFilter
  isBridged: BoolFilter
  isCumulative: BoolFilter
  marketParamsAssertionliveness: DecimalNullableFilter
  marketParamsBondamount: DecimalNullableFilter
  marketParamsBondcurrency: StringNullableFilter
  marketParamsClaimstatementNo: StringNullableFilter
  marketParamsClaimstatementYesOrNumeric: StringNullableFilter
  marketParamsFeerate: IntNullableFilter
  marketParamsOptimisticoraclev3: StringNullableFilter
  marketParamsUniswappositionmanager: StringNullableFilter
  marketParamsUniswapquoter: StringNullableFilter
  marketParamsUniswapswaprouter: StringNullableFilter
  markets: MarketListRelationFilter
  minTradeSize: DecimalNullableFilter
  owner: StringNullableFilter
  question: StringNullableFilter
  quoteTokenName: StringNullableFilter
  resource: ResourceNullableRelationFilter
  resourceId: IntNullableFilter
}

input MarketGroupWhereUniqueInput {
  AND: [MarketGroupWhereInput!]
  NOT: [MarketGroupWhereInput!]
  OR: [MarketGroupWhereInput!]
  address: StringNullableFilter
  address_chainId: MarketGroupAddressChainIdCompoundUniqueInput
  baseTokenName: StringNullableFilter
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  chainId: IntFilter
  collateralAsset: StringNullableFilter
  collateralDecimals: IntNullableFilter
  collateralSymbol: StringNullableFilter
  createdAt: DateTimeFilter
  deployTimestamp: IntNullableFilter
  deployTxnBlockNumber: IntNullableFilter
  events: EventListRelationFilter
  factoryAddress: StringNullableFilter
  id: Int
  initializationNonce: StringNullableFilter
  isBridged: BoolFilter
  isCumulative: BoolFilter
  marketParamsAssertionliveness: DecimalNullableFilter
  marketParamsBondamount: DecimalNullableFilter
  marketParamsBondcurrency: StringNullableFilter
  marketParamsClaimstatementNo: StringNullableFilter
  marketParamsClaimstatementYesOrNumeric: StringNullableFilter
  marketParamsFeerate: IntNullableFilter
  marketParamsOptimisticoraclev3: StringNullableFilter
  marketParamsUniswappositionmanager: StringNullableFilter
  marketParamsUniswapquoter: StringNullableFilter
  marketParamsUniswapswaprouter: StringNullableFilter
  markets: MarketListRelationFilter
  minTradeSize: DecimalNullableFilter
  owner: StringNullableFilter
  question: StringNullableFilter
  quoteTokenName: StringNullableFilter
  resource: ResourceNullableRelationFilter
  resourceId: IntNullableFilter
}

input MarketListRelationFilter {
  every: MarketWhereInput
  none: MarketWhereInput
  some: MarketWhereInput
}

input MarketMarketGroupIdMarketIdCompoundUniqueInput {
  marketGroupId: Int!
  marketId: Int!
}

type MarketMaxAggregate {
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  createdAt: DateTimeISO
  endTimestamp: Int
  id: Int
  marketGroupId: Int
  marketId: Int
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsClaimstatementNo: String
  marketParamsClaimstatementYesOrNumeric: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  maxPriceD18: Decimal
  minPriceD18: Decimal
  optionName: String
  poolAddress: String
  public: Boolean
  question: String
  rules: String
  settled: Boolean
  settlementPriceD18: Decimal
  startTimestamp: Int
  startingSqrtPriceX96: String
}

input MarketMaxOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  createdAt: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsClaimstatementNo: SortOrder
  marketParamsClaimstatementYesOrNumeric: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  optionName: SortOrder
  poolAddress: SortOrder
  public: SortOrder
  question: SortOrder
  rules: SortOrder
  settled: SortOrder
  settlementPriceD18: SortOrder
  startTimestamp: SortOrder
  startingSqrtPriceX96: SortOrder
}

type MarketMinAggregate {
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  createdAt: DateTimeISO
  endTimestamp: Int
  id: Int
  marketGroupId: Int
  marketId: Int
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsClaimstatementNo: String
  marketParamsClaimstatementYesOrNumeric: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  maxPriceD18: Decimal
  minPriceD18: Decimal
  optionName: String
  poolAddress: String
  public: Boolean
  question: String
  rules: String
  settled: Boolean
  settlementPriceD18: Decimal
  startTimestamp: Int
  startingSqrtPriceX96: String
}

input MarketMinOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  createdAt: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsClaimstatementNo: SortOrder
  marketParamsClaimstatementYesOrNumeric: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  optionName: SortOrder
  poolAddress: SortOrder
  public: SortOrder
  question: SortOrder
  rules: SortOrder
  settled: SortOrder
  settlementPriceD18: SortOrder
  startTimestamp: SortOrder
  startingSqrtPriceX96: SortOrder
}

input MarketNullableRelationFilter {
  is: MarketWhereInput
  isNot: MarketWhereInput
}

input MarketOrderByRelationAggregateInput {
  _count: SortOrder
}

input MarketOrderByWithAggregationInput {
  _avg: MarketAvgOrderByAggregateInput
  _count: MarketCountOrderByAggregateInput
  _max: MarketMaxOrderByAggregateInput
  _min: MarketMinOrderByAggregateInput
  _sum: MarketSumOrderByAggregateInput
  baseAssetMaxPriceTick: SortOrderInput
  baseAssetMinPriceTick: SortOrderInput
  createdAt: SortOrder
  endTimestamp: SortOrderInput
  id: SortOrder
  marketGroupId: SortOrderInput
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrderInput
  marketParamsBondamount: SortOrderInput
  marketParamsBondcurrency: SortOrderInput
  marketParamsClaimstatementNo: SortOrderInput
  marketParamsClaimstatementYesOrNumeric: SortOrderInput
  marketParamsFeerate: SortOrderInput
  marketParamsOptimisticoraclev3: SortOrderInput
  marketParamsUniswappositionmanager: SortOrderInput
  marketParamsUniswapquoter: SortOrderInput
  marketParamsUniswapswaprouter: SortOrderInput
  maxPriceD18: SortOrderInput
  minPriceD18: SortOrderInput
  optionName: SortOrderInput
  poolAddress: SortOrderInput
  public: SortOrder
  question: SortOrderInput
  rules: SortOrderInput
  settled: SortOrderInput
  settlementPriceD18: SortOrderInput
  startTimestamp: SortOrderInput
  startingSqrtPriceX96: SortOrderInput
}

input MarketOrderByWithRelationInput {
  baseAssetMaxPriceTick: SortOrderInput
  baseAssetMinPriceTick: SortOrderInput
  createdAt: SortOrder
  endTimestamp: SortOrderInput
  id: SortOrder
  marketGroup: MarketGroupOrderByWithRelationInput
  marketGroupId: SortOrderInput
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrderInput
  marketParamsBondamount: SortOrderInput
  marketParamsBondcurrency: SortOrderInput
  marketParamsClaimstatementNo: SortOrderInput
  marketParamsClaimstatementYesOrNumeric: SortOrderInput
  marketParamsFeerate: SortOrderInput
  marketParamsOptimisticoraclev3: SortOrderInput
  marketParamsUniswappositionmanager: SortOrderInput
  marketParamsUniswapquoter: SortOrderInput
  marketParamsUniswapswaprouter: SortOrderInput
  maxPriceD18: SortOrderInput
  minPriceD18: SortOrderInput
  optionName: SortOrderInput
  poolAddress: SortOrderInput
  positions: PositionOrderByRelationAggregateInput
  public: SortOrder
  question: SortOrderInput
  rules: SortOrderInput
  settled: SortOrderInput
  settlementPriceD18: SortOrderInput
  startTimestamp: SortOrderInput
  startingSqrtPriceX96: SortOrderInput
}

type MarketPrice {
  createdAt: DateTimeISO!
  id: Int!
  timestamp: BigInt!
  transaction(where: TransactionWhereInput): Transaction
  value: Decimal!
}

type MarketPriceAvgAggregate {
  id: Float
  timestamp: Float
  value: Decimal
}

input MarketPriceAvgOrderByAggregateInput {
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

type MarketPriceCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  timestamp: Int!
  value: Int!
}

input MarketPriceCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

type MarketPriceGroupBy {
  _avg: MarketPriceAvgAggregate
  _count: MarketPriceCountAggregate
  _max: MarketPriceMaxAggregate
  _min: MarketPriceMinAggregate
  _sum: MarketPriceSumAggregate
  createdAt: DateTimeISO!
  id: Int!
  timestamp: BigInt!
  value: Decimal!
}

type MarketPriceMaxAggregate {
  createdAt: DateTimeISO
  id: Int
  timestamp: BigInt
  value: Decimal
}

input MarketPriceMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

type MarketPriceMinAggregate {
  createdAt: DateTimeISO
  id: Int
  timestamp: BigInt
  value: Decimal
}

input MarketPriceMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

input MarketPriceNullableRelationFilter {
  is: MarketPriceWhereInput
  isNot: MarketPriceWhereInput
}

input MarketPriceOrderByWithAggregationInput {
  _avg: MarketPriceAvgOrderByAggregateInput
  _count: MarketPriceCountOrderByAggregateInput
  _max: MarketPriceMaxOrderByAggregateInput
  _min: MarketPriceMinOrderByAggregateInput
  _sum: MarketPriceSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

input MarketPriceOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  transaction: TransactionOrderByWithRelationInput
  value: SortOrder
}

enum MarketPriceScalarFieldEnum {
  createdAt
  id
  timestamp
  value
}

input MarketPriceScalarWhereWithAggregatesInput {
  AND: [MarketPriceScalarWhereWithAggregatesInput!]
  NOT: [MarketPriceScalarWhereWithAggregatesInput!]
  OR: [MarketPriceScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  timestamp: BigIntWithAggregatesFilter
  value: DecimalWithAggregatesFilter
}

type MarketPriceSumAggregate {
  id: Int
  timestamp: BigInt
  value: Decimal
}

input MarketPriceSumOrderByAggregateInput {
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

input MarketPriceWhereInput {
  AND: [MarketPriceWhereInput!]
  NOT: [MarketPriceWhereInput!]
  OR: [MarketPriceWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  timestamp: BigIntFilter
  transaction: TransactionNullableRelationFilter
  value: DecimalFilter
}

input MarketPriceWhereUniqueInput {
  AND: [MarketPriceWhereInput!]
  NOT: [MarketPriceWhereInput!]
  OR: [MarketPriceWhereInput!]
  createdAt: DateTimeFilter
  id: Int
  timestamp: BigIntFilter
  transaction: TransactionNullableRelationFilter
  value: DecimalFilter
}

enum MarketScalarFieldEnum {
  baseAssetMaxPriceTick
  baseAssetMinPriceTick
  createdAt
  endTimestamp
  id
  marketGroupId
  marketId
  marketParamsAssertionliveness
  marketParamsBondamount
  marketParamsBondcurrency
  marketParamsClaimstatementNo
  marketParamsClaimstatementYesOrNumeric
  marketParamsFeerate
  marketParamsOptimisticoraclev3
  marketParamsUniswappositionmanager
  marketParamsUniswapquoter
  marketParamsUniswapswaprouter
  maxPriceD18
  minPriceD18
  optionName
  poolAddress
  public
  question
  rules
  settled
  settlementPriceD18
  startTimestamp
  startingSqrtPriceX96
}

input MarketScalarWhereWithAggregatesInput {
  AND: [MarketScalarWhereWithAggregatesInput!]
  NOT: [MarketScalarWhereWithAggregatesInput!]
  OR: [MarketScalarWhereWithAggregatesInput!]
  baseAssetMaxPriceTick: IntNullableWithAggregatesFilter
  baseAssetMinPriceTick: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  endTimestamp: IntNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  marketGroupId: IntNullableWithAggregatesFilter
  marketId: IntWithAggregatesFilter
  marketParamsAssertionliveness: DecimalNullableWithAggregatesFilter
  marketParamsBondamount: DecimalNullableWithAggregatesFilter
  marketParamsBondcurrency: StringNullableWithAggregatesFilter
  marketParamsClaimstatementNo: StringNullableWithAggregatesFilter
  marketParamsClaimstatementYesOrNumeric: StringNullableWithAggregatesFilter
  marketParamsFeerate: IntNullableWithAggregatesFilter
  marketParamsOptimisticoraclev3: StringNullableWithAggregatesFilter
  marketParamsUniswappositionmanager: StringNullableWithAggregatesFilter
  marketParamsUniswapquoter: StringNullableWithAggregatesFilter
  marketParamsUniswapswaprouter: StringNullableWithAggregatesFilter
  maxPriceD18: DecimalNullableWithAggregatesFilter
  minPriceD18: DecimalNullableWithAggregatesFilter
  optionName: StringNullableWithAggregatesFilter
  poolAddress: StringNullableWithAggregatesFilter
  public: BoolWithAggregatesFilter
  question: StringNullableWithAggregatesFilter
  rules: StringNullableWithAggregatesFilter
  settled: BoolNullableWithAggregatesFilter
  settlementPriceD18: DecimalNullableWithAggregatesFilter
  startTimestamp: IntNullableWithAggregatesFilter
  startingSqrtPriceX96: StringNullableWithAggregatesFilter
}

type MarketSumAggregate {
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  endTimestamp: Int
  id: Int
  marketGroupId: Int
  marketId: Int
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsFeerate: Int
  maxPriceD18: Decimal
  minPriceD18: Decimal
  settlementPriceD18: Decimal
  startTimestamp: Int
}

input MarketSumOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsFeerate: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  settlementPriceD18: SortOrder
  startTimestamp: SortOrder
}

input MarketWhereInput {
  AND: [MarketWhereInput!]
  NOT: [MarketWhereInput!]
  OR: [MarketWhereInput!]
  baseAssetMaxPriceTick: IntNullableFilter
  baseAssetMinPriceTick: IntNullableFilter
  createdAt: DateTimeFilter
  endTimestamp: IntNullableFilter
  id: IntFilter
  marketGroup: MarketGroupNullableRelationFilter
  marketGroupId: IntNullableFilter
  marketId: IntFilter
  marketParamsAssertionliveness: DecimalNullableFilter
  marketParamsBondamount: DecimalNullableFilter
  marketParamsBondcurrency: StringNullableFilter
  marketParamsClaimstatementNo: StringNullableFilter
  marketParamsClaimstatementYesOrNumeric: StringNullableFilter
  marketParamsFeerate: IntNullableFilter
  marketParamsOptimisticoraclev3: StringNullableFilter
  marketParamsUniswappositionmanager: StringNullableFilter
  marketParamsUniswapquoter: StringNullableFilter
  marketParamsUniswapswaprouter: StringNullableFilter
  maxPriceD18: DecimalNullableFilter
  minPriceD18: DecimalNullableFilter
  optionName: StringNullableFilter
  poolAddress: StringNullableFilter
  positions: PositionListRelationFilter
  public: BoolFilter
  question: StringNullableFilter
  rules: StringNullableFilter
  settled: BoolNullableFilter
  settlementPriceD18: DecimalNullableFilter
  startTimestamp: IntNullableFilter
  startingSqrtPriceX96: StringNullableFilter
}

input MarketWhereUniqueInput {
  AND: [MarketWhereInput!]
  NOT: [MarketWhereInput!]
  OR: [MarketWhereInput!]
  baseAssetMaxPriceTick: IntNullableFilter
  baseAssetMinPriceTick: IntNullableFilter
  createdAt: DateTimeFilter
  endTimestamp: IntNullableFilter
  id: Int
  marketGroup: MarketGroupNullableRelationFilter
  marketGroupId: IntNullableFilter
  marketGroupId_marketId: MarketMarketGroupIdMarketIdCompoundUniqueInput
  marketId: IntFilter
  marketParamsAssertionliveness: DecimalNullableFilter
  marketParamsBondamount: DecimalNullableFilter
  marketParamsBondcurrency: StringNullableFilter
  marketParamsClaimstatementNo: StringNullableFilter
  marketParamsClaimstatementYesOrNumeric: StringNullableFilter
  marketParamsFeerate: IntNullableFilter
  marketParamsOptimisticoraclev3: StringNullableFilter
  marketParamsUniswappositionmanager: StringNullableFilter
  marketParamsUniswapquoter: StringNullableFilter
  marketParamsUniswapswaprouter: StringNullableFilter
  maxPriceD18: DecimalNullableFilter
  minPriceD18: DecimalNullableFilter
  optionName: StringNullableFilter
  poolAddress: StringNullableFilter
  positions: PositionListRelationFilter
  public: BoolFilter
  question: StringNullableFilter
  rules: StringNullableFilter
  settled: BoolNullableFilter
  settlementPriceD18: DecimalNullableFilter
  startTimestamp: IntNullableFilter
  startingSqrtPriceX96: StringNullableFilter
}

input NestedBigIntFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntFilter
  notIn: [BigInt!]
}

input NestedBigIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedBigIntFilter
  _min: NestedBigIntFilter
  _sum: NestedBigIntFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntWithAggregatesFilter
  notIn: [BigInt!]
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedBoolNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBoolNullableFilter
  _min: NestedBoolNullableFilter
  equals: Boolean
  not: NestedBoolNullableWithAggregatesFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input NestedDecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input NestedDecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedDecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedEnumtransaction_type_enumFilter {
  equals: transaction_type_enum
  in: [transaction_type_enum!]
  not: NestedEnumtransaction_type_enumFilter
  notIn: [transaction_type_enum!]
}

input NestedEnumtransaction_type_enumWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumtransaction_type_enumFilter
  _min: NestedEnumtransaction_type_enumFilter
  equals: transaction_type_enum
  in: [transaction_type_enum!]
  not: NestedEnumtransaction_type_enumWithAggregatesFilter
  notIn: [transaction_type_enum!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type PnLType {
  marketId: Int!
  openPositionsPnL: String!
  owner: String!
  positionCount: Int!
  positions: [Int!]!
  totalDeposits: String!
  totalPnL: String!
  totalWithdrawals: String!
}

type Position {
  _count: PositionCount
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal!
  createdAt: DateTimeISO!
  highPriceTick: Decimal
  id: Int!
  isLP: Boolean!
  isSettled: Boolean
  lowPriceTick: Decimal
  lpBaseToken: Decimal
  lpQuoteToken: Decimal
  market(where: MarketWhereInput): Market
  marketId: Int
  owner: String
  positionId: Int!
  quoteToken: Decimal
  transactions(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): [Transaction!]!
}

type PositionAvgAggregate {
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal
  highPriceTick: Decimal
  id: Float
  lowPriceTick: Decimal
  lpBaseToken: Decimal
  lpQuoteToken: Decimal
  marketId: Float
  positionId: Float
  quoteToken: Decimal
}

input PositionAvgOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  highPriceTick: SortOrder
  id: SortOrder
  lowPriceTick: SortOrder
  lpBaseToken: SortOrder
  lpQuoteToken: SortOrder
  marketId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
}

type PositionCount {
  transaction(where: TransactionWhereInput): Int!
}

type PositionCountAggregate {
  _all: Int!
  baseToken: Int!
  borrowedBaseToken: Int!
  borrowedQuoteToken: Int!
  collateral: Int!
  createdAt: Int!
  highPriceTick: Int!
  id: Int!
  isLP: Int!
  isSettled: Int!
  lowPriceTick: Int!
  lpBaseToken: Int!
  lpQuoteToken: Int!
  marketId: Int!
  owner: Int!
  positionId: Int!
  quoteToken: Int!
}

input PositionCountOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrder
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrder
  lowPriceTick: SortOrder
  lpBaseToken: SortOrder
  lpQuoteToken: SortOrder
  marketId: SortOrder
  owner: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
}

type PositionGroupBy {
  _avg: PositionAvgAggregate
  _count: PositionCountAggregate
  _max: PositionMaxAggregate
  _min: PositionMinAggregate
  _sum: PositionSumAggregate
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal!
  createdAt: DateTimeISO!
  highPriceTick: Decimal
  id: Int!
  isLP: Boolean!
  isSettled: Boolean
  lowPriceTick: Decimal
  lpBaseToken: Decimal
  lpQuoteToken: Decimal
  marketId: Int
  owner: String
  positionId: Int!
  quoteToken: Decimal
}

input PositionListRelationFilter {
  every: PositionWhereInput
  none: PositionWhereInput
  some: PositionWhereInput
}

type PositionMaxAggregate {
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal
  createdAt: DateTimeISO
  highPriceTick: Decimal
  id: Int
  isLP: Boolean
  isSettled: Boolean
  lowPriceTick: Decimal
  lpBaseToken: Decimal
  lpQuoteToken: Decimal
  marketId: Int
  owner: String
  positionId: Int
  quoteToken: Decimal
}

input PositionMaxOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrder
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrder
  lowPriceTick: SortOrder
  lpBaseToken: SortOrder
  lpQuoteToken: SortOrder
  marketId: SortOrder
  owner: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
}

type PositionMinAggregate {
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal
  createdAt: DateTimeISO
  highPriceTick: Decimal
  id: Int
  isLP: Boolean
  isSettled: Boolean
  lowPriceTick: Decimal
  lpBaseToken: Decimal
  lpQuoteToken: Decimal
  marketId: Int
  owner: String
  positionId: Int
  quoteToken: Decimal
}

input PositionMinOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrder
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrder
  lowPriceTick: SortOrder
  lpBaseToken: SortOrder
  lpQuoteToken: SortOrder
  marketId: SortOrder
  owner: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
}

input PositionNullableRelationFilter {
  is: PositionWhereInput
  isNot: PositionWhereInput
}

input PositionOrderByRelationAggregateInput {
  _count: SortOrder
}

input PositionOrderByWithAggregationInput {
  _avg: PositionAvgOrderByAggregateInput
  _count: PositionCountOrderByAggregateInput
  _max: PositionMaxOrderByAggregateInput
  _min: PositionMinOrderByAggregateInput
  _sum: PositionSumOrderByAggregateInput
  baseToken: SortOrderInput
  borrowedBaseToken: SortOrderInput
  borrowedQuoteToken: SortOrderInput
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrderInput
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrderInput
  lowPriceTick: SortOrderInput
  lpBaseToken: SortOrderInput
  lpQuoteToken: SortOrderInput
  marketId: SortOrderInput
  owner: SortOrderInput
  positionId: SortOrder
  quoteToken: SortOrderInput
}

input PositionOrderByWithRelationInput {
  baseToken: SortOrderInput
  borrowedBaseToken: SortOrderInput
  borrowedQuoteToken: SortOrderInput
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrderInput
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrderInput
  lowPriceTick: SortOrderInput
  lpBaseToken: SortOrderInput
  lpQuoteToken: SortOrderInput
  market: MarketOrderByWithRelationInput
  marketId: SortOrderInput
  owner: SortOrderInput
  positionId: SortOrder
  quoteToken: SortOrderInput
  transactions: TransactionOrderByRelationAggregateInput
}

input PositionPositionIdMarketIdCompoundUniqueInput {
  marketId: Int!
  positionId: Int!
}

enum PositionScalarFieldEnum {
  baseToken
  borrowedBaseToken
  borrowedQuoteToken
  collateral
  createdAt
  highPriceTick
  id
  isLP
  isSettled
  lowPriceTick
  lpBaseToken
  lpQuoteToken
  marketId
  owner
  positionId
  quoteToken
}

input PositionScalarWhereWithAggregatesInput {
  AND: [PositionScalarWhereWithAggregatesInput!]
  NOT: [PositionScalarWhereWithAggregatesInput!]
  OR: [PositionScalarWhereWithAggregatesInput!]
  baseToken: DecimalNullableWithAggregatesFilter
  borrowedBaseToken: DecimalNullableWithAggregatesFilter
  borrowedQuoteToken: DecimalNullableWithAggregatesFilter
  collateral: DecimalWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  highPriceTick: DecimalNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  isLP: BoolWithAggregatesFilter
  isSettled: BoolNullableWithAggregatesFilter
  lowPriceTick: DecimalNullableWithAggregatesFilter
  lpBaseToken: DecimalNullableWithAggregatesFilter
  lpQuoteToken: DecimalNullableWithAggregatesFilter
  marketId: IntNullableWithAggregatesFilter
  owner: StringNullableWithAggregatesFilter
  positionId: IntWithAggregatesFilter
  quoteToken: DecimalNullableWithAggregatesFilter
}

type PositionSumAggregate {
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal
  highPriceTick: Decimal
  id: Int
  lowPriceTick: Decimal
  lpBaseToken: Decimal
  lpQuoteToken: Decimal
  marketId: Int
  positionId: Int
  quoteToken: Decimal
}

input PositionSumOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  highPriceTick: SortOrder
  id: SortOrder
  lowPriceTick: SortOrder
  lpBaseToken: SortOrder
  lpQuoteToken: SortOrder
  marketId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
}

input PositionWhereInput {
  AND: [PositionWhereInput!]
  NOT: [PositionWhereInput!]
  OR: [PositionWhereInput!]
  baseToken: DecimalNullableFilter
  borrowedBaseToken: DecimalNullableFilter
  borrowedQuoteToken: DecimalNullableFilter
  collateral: DecimalFilter
  createdAt: DateTimeFilter
  highPriceTick: DecimalNullableFilter
  id: IntFilter
  isLP: BoolFilter
  isSettled: BoolNullableFilter
  lowPriceTick: DecimalNullableFilter
  lpBaseToken: DecimalNullableFilter
  lpQuoteToken: DecimalNullableFilter
  market: MarketNullableRelationFilter
  marketId: IntNullableFilter
  owner: StringNullableFilter
  positionId: IntFilter
  quoteToken: DecimalNullableFilter
  transactions: TransactionListRelationFilter
}

input PositionWhereUniqueInput {
  AND: [PositionWhereInput!]
  NOT: [PositionWhereInput!]
  OR: [PositionWhereInput!]
  baseToken: DecimalNullableFilter
  borrowedBaseToken: DecimalNullableFilter
  borrowedQuoteToken: DecimalNullableFilter
  collateral: DecimalFilter
  createdAt: DateTimeFilter
  highPriceTick: DecimalNullableFilter
  id: Int
  isLP: BoolFilter
  isSettled: BoolNullableFilter
  lowPriceTick: DecimalNullableFilter
  lpBaseToken: DecimalNullableFilter
  lpQuoteToken: DecimalNullableFilter
  market: MarketNullableRelationFilter
  marketId: IntNullableFilter
  owner: StringNullableFilter
  positionId: IntFilter
  positionId_marketId: PositionPositionIdMarketIdCompoundUniqueInput
  quoteToken: DecimalNullableFilter
  transactions: TransactionListRelationFilter
}

type Query {
  aggregateCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory!
  aggregateCryptoPrices(cursor: CryptoPricesWhereUniqueInput, orderBy: [CryptoPricesOrderByWithRelationInput!], skip: Int, take: Int, where: CryptoPricesWhereInput): AggregateCryptoPrices!
  aggregateMarket(cursor: MarketWhereUniqueInput, orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): AggregateMarket!
  aggregateMarketGroup(cursor: MarketGroupWhereUniqueInput, orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): AggregateMarketGroup!
  aggregateMarketPrice(cursor: MarketPriceWhereUniqueInput, orderBy: [MarketPriceOrderByWithRelationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): AggregateMarketPrice!
  aggregatePosition(cursor: PositionWhereUniqueInput, orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): AggregatePosition!
  aggregateResource(cursor: ResourceWhereUniqueInput, orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): AggregateResource!
  aggregateResourcePrice(cursor: ResourcePriceWhereUniqueInput, orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): AggregateResourcePrice!
  aggregateTransaction(cursor: TransactionWhereUniqueInput, orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): AggregateTransaction!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCategoryOrThrow(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCryptoPrices(cursor: CryptoPricesWhereUniqueInput, distinct: [CryptoPricesScalarFieldEnum!], orderBy: [CryptoPricesOrderByWithRelationInput!], skip: Int, take: Int, where: CryptoPricesWhereInput): CryptoPrices
  findFirstCryptoPricesOrThrow(cursor: CryptoPricesWhereUniqueInput, distinct: [CryptoPricesScalarFieldEnum!], orderBy: [CryptoPricesOrderByWithRelationInput!], skip: Int, take: Int, where: CryptoPricesWhereInput): CryptoPrices
  findFirstMarket(cursor: MarketWhereUniqueInput, distinct: [MarketScalarFieldEnum!], orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): Market
  findFirstMarketGroup(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): MarketGroup
  findFirstMarketGroupOrThrow(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): MarketGroup
  findFirstMarketOrThrow(cursor: MarketWhereUniqueInput, distinct: [MarketScalarFieldEnum!], orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): Market
  findFirstMarketPrice(cursor: MarketPriceWhereUniqueInput, distinct: [MarketPriceScalarFieldEnum!], orderBy: [MarketPriceOrderByWithRelationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): MarketPrice
  findFirstMarketPriceOrThrow(cursor: MarketPriceWhereUniqueInput, distinct: [MarketPriceScalarFieldEnum!], orderBy: [MarketPriceOrderByWithRelationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): MarketPrice
  findFirstPosition(cursor: PositionWhereUniqueInput, distinct: [PositionScalarFieldEnum!], orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): Position
  findFirstPositionOrThrow(cursor: PositionWhereUniqueInput, distinct: [PositionScalarFieldEnum!], orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): Position
  findFirstResource(cursor: ResourceWhereUniqueInput, distinct: [ResourceScalarFieldEnum!], orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): Resource
  findFirstResourceOrThrow(cursor: ResourceWhereUniqueInput, distinct: [ResourceScalarFieldEnum!], orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): Resource
  findFirstResourcePrice(cursor: ResourcePriceWhereUniqueInput, distinct: [ResourcePriceScalarFieldEnum!], orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): ResourcePrice
  findFirstResourcePriceOrThrow(cursor: ResourcePriceWhereUniqueInput, distinct: [ResourcePriceScalarFieldEnum!], orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): ResourcePrice
  findFirstTransaction(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): Transaction
  findFirstTransactionOrThrow(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): Transaction
  findManyCryptoPrices(cursor: CryptoPricesWhereUniqueInput, distinct: [CryptoPricesScalarFieldEnum!], orderBy: [CryptoPricesOrderByWithRelationInput!], skip: Int, take: Int, where: CryptoPricesWhereInput): [CryptoPrices!]!
  findUniqueCryptoPrices(where: CryptoPricesWhereUniqueInput!): CryptoPrices
  findUniqueCryptoPricesOrThrow(where: CryptoPricesWhereUniqueInput!): CryptoPrices
  getCategory(where: CategoryWhereUniqueInput!): Category
  getMarket(where: MarketWhereUniqueInput!): Market
  getMarketGroup(where: MarketGroupWhereUniqueInput!): MarketGroup
  getMarketLeaderboard(address: String!, chainId: Int!, marketId: String!): [PnLType!]!
  getMarketPrice(where: MarketPriceWhereUniqueInput!): MarketPrice
  getPosition(where: PositionWhereUniqueInput!): Position
  getResource(where: ResourceWhereUniqueInput!): Resource
  getResourcePrice(where: ResourcePriceWhereUniqueInput!): ResourcePrice
  getTransaction(where: TransactionWhereUniqueInput!): Transaction
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByWithAggregationInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByCryptoPrices(by: [CryptoPricesScalarFieldEnum!]!, having: CryptoPricesScalarWhereWithAggregatesInput, orderBy: [CryptoPricesOrderByWithAggregationInput!], skip: Int, take: Int, where: CryptoPricesWhereInput): [CryptoPricesGroupBy!]!
  groupByMarket(by: [MarketScalarFieldEnum!]!, having: MarketScalarWhereWithAggregatesInput, orderBy: [MarketOrderByWithAggregationInput!], skip: Int, take: Int, where: MarketWhereInput): [MarketGroupBy!]!
  groupByMarketGroup(by: [MarketGroupScalarFieldEnum!]!, having: MarketGroupScalarWhereWithAggregatesInput, orderBy: [MarketGroupOrderByWithAggregationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): [MarketGroupGroupBy!]!
  groupByMarketPrice(by: [MarketPriceScalarFieldEnum!]!, having: MarketPriceScalarWhereWithAggregatesInput, orderBy: [MarketPriceOrderByWithAggregationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): [MarketPriceGroupBy!]!
  groupByPosition(by: [PositionScalarFieldEnum!]!, having: PositionScalarWhereWithAggregatesInput, orderBy: [PositionOrderByWithAggregationInput!], skip: Int, take: Int, where: PositionWhereInput): [PositionGroupBy!]!
  groupByResource(by: [ResourceScalarFieldEnum!]!, having: ResourceScalarWhereWithAggregatesInput, orderBy: [ResourceOrderByWithAggregationInput!], skip: Int, take: Int, where: ResourceWhereInput): [ResourceGroupBy!]!
  groupByResourcePrice(by: [ResourcePriceScalarFieldEnum!]!, having: ResourcePriceScalarWhereWithAggregatesInput, orderBy: [ResourcePriceOrderByWithAggregationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): [ResourcePriceGroupBy!]!
  groupByTransaction(by: [TransactionScalarFieldEnum!]!, having: TransactionScalarWhereWithAggregatesInput, orderBy: [TransactionOrderByWithAggregationInput!], skip: Int, take: Int, where: TransactionWhereInput): [TransactionGroupBy!]!
  indexCandles(address: String!, chainId: Int!, from: Int!, interval: Int!, marketId: String!, to: Int!): CandleAndTimestampType!
  indexPriceAtTime(address: String!, chainId: Int!, marketId: String!, timestamp: Int!): CandleType
  legacyMarketCandles(address: String!, chainId: Int!, from: Int!, interval: Int!, marketId: String!, to: Int!): [CandleType!]!
  market(where: MarketWhereUniqueInput!): Market
  marketCandles(address: String!, chainId: Int!, from: Int!, interval: Int!, marketId: String!, to: Int!): CandleAndTimestampType!
  marketGroup(where: MarketGroupWhereUniqueInput!): MarketGroup
  marketGroups(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): [MarketGroup!]!
  marketPrice(where: MarketPriceWhereUniqueInput!): MarketPrice
  marketPrices(cursor: MarketPriceWhereUniqueInput, distinct: [MarketPriceScalarFieldEnum!], orderBy: [MarketPriceOrderByWithRelationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): [MarketPrice!]!
  markets(cursor: MarketWhereUniqueInput, distinct: [MarketScalarFieldEnum!], orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): [Market!]!
  position(where: PositionWhereUniqueInput!): Position
  positions(cursor: PositionWhereUniqueInput, distinct: [PositionScalarFieldEnum!], orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): [Position!]!
  resource(where: ResourceWhereUniqueInput!): Resource
  resourceCandles(from: Int!, interval: Int!, slug: String!, to: Int!): CandleAndTimestampType!
  resourcePrice(where: ResourcePriceWhereUniqueInput!): ResourcePrice
  resourcePrices(cursor: ResourcePriceWhereUniqueInput, distinct: [ResourcePriceScalarFieldEnum!], orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): [ResourcePrice!]!
  resourceTrailingAverageCandles(from: Int!, interval: Int!, slug: String!, to: Int!, trailingAvgTime: Int!): CandleAndTimestampType!
  resources(cursor: ResourceWhereUniqueInput, distinct: [ResourceScalarFieldEnum!], orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): [Resource!]!
  totalVolumeByMarket(chainId: Int!, marketAddress: String!, marketId: Int!): Float!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): [Transaction!]!
}

enum QueryMode {
  default
  insensitive
}

type Resource {
  _count: ResourceCount
  category(where: CategoryWhereInput): Category
  categoryId: Int
  createdAt: DateTimeISO!
  id: Int!
  marketGroups(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): [MarketGroup!]!
  name: String!
  resourcePrices(cursor: ResourcePriceWhereUniqueInput, distinct: [ResourcePriceScalarFieldEnum!], orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): [ResourcePrice!]!
  slug: String!
}

type ResourceAvgAggregate {
  categoryId: Float
  id: Float
}

input ResourceAvgOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
}

type ResourceCount {
  market_group(where: MarketGroupWhereInput): Int!
  resource_price(where: ResourcePriceWhereInput): Int!
}

type ResourceCountAggregate {
  _all: Int!
  categoryId: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  slug: Int!
}

input ResourceCountOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type ResourceGroupBy {
  _avg: ResourceAvgAggregate
  _count: ResourceCountAggregate
  _max: ResourceMaxAggregate
  _min: ResourceMinAggregate
  _sum: ResourceSumAggregate
  categoryId: Int
  createdAt: DateTimeISO!
  id: Int!
  name: String!
  slug: String!
}

input ResourceListRelationFilter {
  every: ResourceWhereInput
  none: ResourceWhereInput
  some: ResourceWhereInput
}

type ResourceMaxAggregate {
  categoryId: Int
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input ResourceMaxOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type ResourceMinAggregate {
  categoryId: Int
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input ResourceMinOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input ResourceNullableRelationFilter {
  is: ResourceWhereInput
  isNot: ResourceWhereInput
}

input ResourceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResourceOrderByWithAggregationInput {
  _avg: ResourceAvgOrderByAggregateInput
  _count: ResourceCountOrderByAggregateInput
  _max: ResourceMaxOrderByAggregateInput
  _min: ResourceMinOrderByAggregateInput
  _sum: ResourceSumOrderByAggregateInput
  categoryId: SortOrderInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input ResourceOrderByWithRelationInput {
  category: CategoryOrderByWithRelationInput
  categoryId: SortOrderInput
  createdAt: SortOrder
  id: SortOrder
  marketGroups: MarketGroupOrderByRelationAggregateInput
  name: SortOrder
  resourcePrices: ResourcePriceOrderByRelationAggregateInput
  slug: SortOrder
}

type ResourcePrice {
  blockNumber: Int!
  createdAt: DateTimeISO!
  feePaid: Decimal!
  id: Int!
  resource(where: ResourceWhereInput): Resource
  resourceId: Int
  timestamp: Int!
  used: Decimal!
  value: Decimal!
}

type ResourcePriceAvgAggregate {
  blockNumber: Float
  feePaid: Decimal
  id: Float
  resourceId: Float
  timestamp: Float
  used: Decimal
  value: Decimal
}

input ResourcePriceAvgOrderByAggregateInput {
  blockNumber: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

type ResourcePriceCountAggregate {
  _all: Int!
  blockNumber: Int!
  createdAt: Int!
  feePaid: Int!
  id: Int!
  resourceId: Int!
  timestamp: Int!
  used: Int!
  value: Int!
}

input ResourcePriceCountOrderByAggregateInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

type ResourcePriceGroupBy {
  _avg: ResourcePriceAvgAggregate
  _count: ResourcePriceCountAggregate
  _max: ResourcePriceMaxAggregate
  _min: ResourcePriceMinAggregate
  _sum: ResourcePriceSumAggregate
  blockNumber: Int!
  createdAt: DateTimeISO!
  feePaid: Decimal!
  id: Int!
  resourceId: Int
  timestamp: Int!
  used: Decimal!
  value: Decimal!
}

input ResourcePriceListRelationFilter {
  every: ResourcePriceWhereInput
  none: ResourcePriceWhereInput
  some: ResourcePriceWhereInput
}

type ResourcePriceMaxAggregate {
  blockNumber: Int
  createdAt: DateTimeISO
  feePaid: Decimal
  id: Int
  resourceId: Int
  timestamp: Int
  used: Decimal
  value: Decimal
}

input ResourcePriceMaxOrderByAggregateInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

type ResourcePriceMinAggregate {
  blockNumber: Int
  createdAt: DateTimeISO
  feePaid: Decimal
  id: Int
  resourceId: Int
  timestamp: Int
  used: Decimal
  value: Decimal
}

input ResourcePriceMinOrderByAggregateInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

input ResourcePriceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResourcePriceOrderByWithAggregationInput {
  _avg: ResourcePriceAvgOrderByAggregateInput
  _count: ResourcePriceCountOrderByAggregateInput
  _max: ResourcePriceMaxOrderByAggregateInput
  _min: ResourcePriceMinOrderByAggregateInput
  _sum: ResourcePriceSumOrderByAggregateInput
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrderInput
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

input ResourcePriceOrderByWithRelationInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resource: ResourceOrderByWithRelationInput
  resourceId: SortOrderInput
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

input ResourcePriceResourceIdTimestampCompoundUniqueInput {
  resourceId: Int!
  timestamp: Int!
}

enum ResourcePriceScalarFieldEnum {
  blockNumber
  createdAt
  feePaid
  id
  resourceId
  timestamp
  used
  value
}

input ResourcePriceScalarWhereWithAggregatesInput {
  AND: [ResourcePriceScalarWhereWithAggregatesInput!]
  NOT: [ResourcePriceScalarWhereWithAggregatesInput!]
  OR: [ResourcePriceScalarWhereWithAggregatesInput!]
  blockNumber: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  feePaid: DecimalWithAggregatesFilter
  id: IntWithAggregatesFilter
  resourceId: IntNullableWithAggregatesFilter
  timestamp: IntWithAggregatesFilter
  used: DecimalWithAggregatesFilter
  value: DecimalWithAggregatesFilter
}

type ResourcePriceSumAggregate {
  blockNumber: Int
  feePaid: Decimal
  id: Int
  resourceId: Int
  timestamp: Int
  used: Decimal
  value: Decimal
}

input ResourcePriceSumOrderByAggregateInput {
  blockNumber: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

input ResourcePriceWhereInput {
  AND: [ResourcePriceWhereInput!]
  NOT: [ResourcePriceWhereInput!]
  OR: [ResourcePriceWhereInput!]
  blockNumber: IntFilter
  createdAt: DateTimeFilter
  feePaid: DecimalFilter
  id: IntFilter
  resource: ResourceNullableRelationFilter
  resourceId: IntNullableFilter
  timestamp: IntFilter
  used: DecimalFilter
  value: DecimalFilter
}

input ResourcePriceWhereUniqueInput {
  AND: [ResourcePriceWhereInput!]
  NOT: [ResourcePriceWhereInput!]
  OR: [ResourcePriceWhereInput!]
  blockNumber: IntFilter
  createdAt: DateTimeFilter
  feePaid: DecimalFilter
  id: Int
  resource: ResourceNullableRelationFilter
  resourceId: IntNullableFilter
  resourceId_timestamp: ResourcePriceResourceIdTimestampCompoundUniqueInput
  timestamp: IntFilter
  used: DecimalFilter
  value: DecimalFilter
}

enum ResourceScalarFieldEnum {
  categoryId
  createdAt
  id
  name
  slug
}

input ResourceScalarWhereWithAggregatesInput {
  AND: [ResourceScalarWhereWithAggregatesInput!]
  NOT: [ResourceScalarWhereWithAggregatesInput!]
  OR: [ResourceScalarWhereWithAggregatesInput!]
  categoryId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  slug: StringWithAggregatesFilter
}

type ResourceSumAggregate {
  categoryId: Int
  id: Int
}

input ResourceSumOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
}

input ResourceWhereInput {
  AND: [ResourceWhereInput!]
  NOT: [ResourceWhereInput!]
  OR: [ResourceWhereInput!]
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  marketGroups: MarketGroupListRelationFilter
  name: StringFilter
  resourcePrices: ResourcePriceListRelationFilter
  slug: StringFilter
}

input ResourceWhereUniqueInput {
  AND: [ResourceWhereInput!]
  NOT: [ResourceWhereInput!]
  OR: [ResourceWhereInput!]
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  createdAt: DateTimeFilter
  id: Int
  marketGroups: MarketGroupListRelationFilter
  name: String
  resourcePrices: ResourcePriceListRelationFilter
  slug: String
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Transaction {
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal!
  collateralTransfer(where: CollateralTransferWhereInput): CollateralTransfer
  collateralTransferId: Int
  createdAt: DateTimeISO!
  event(where: EventWhereInput): Event
  eventId: Int
  id: Int!
  lpBaseDeltaToken: Decimal
  lpQuoteDeltaToken: Decimal
  marketPrice(where: MarketPriceWhereInput): MarketPrice
  marketPriceId: Int
  position(where: PositionWhereInput): Position
  positionId: Int
  quoteToken: Decimal
  tradeRatioD18: Decimal
  type: transaction_type_enum!
}

type TransactionAvgAggregate {
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal
  collateralTransferId: Float
  eventId: Float
  id: Float
  lpBaseDeltaToken: Decimal
  lpQuoteDeltaToken: Decimal
  marketPriceId: Float
  positionId: Float
  quoteToken: Decimal
  tradeRatioD18: Decimal
}

input TransactionAvgOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  collateralTransferId: SortOrder
  eventId: SortOrder
  id: SortOrder
  lpBaseDeltaToken: SortOrder
  lpQuoteDeltaToken: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
  tradeRatioD18: SortOrder
}

type TransactionCountAggregate {
  _all: Int!
  baseToken: Int!
  borrowedBaseToken: Int!
  borrowedQuoteToken: Int!
  collateral: Int!
  collateralTransferId: Int!
  createdAt: Int!
  eventId: Int!
  id: Int!
  lpBaseDeltaToken: Int!
  lpQuoteDeltaToken: Int!
  marketPriceId: Int!
  positionId: Int!
  quoteToken: Int!
  tradeRatioD18: Int!
  type: Int!
}

input TransactionCountOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  collateralTransferId: SortOrder
  createdAt: SortOrder
  eventId: SortOrder
  id: SortOrder
  lpBaseDeltaToken: SortOrder
  lpQuoteDeltaToken: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
  tradeRatioD18: SortOrder
  type: SortOrder
}

type TransactionGroupBy {
  _avg: TransactionAvgAggregate
  _count: TransactionCountAggregate
  _max: TransactionMaxAggregate
  _min: TransactionMinAggregate
  _sum: TransactionSumAggregate
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal!
  collateralTransferId: Int
  createdAt: DateTimeISO!
  eventId: Int
  id: Int!
  lpBaseDeltaToken: Decimal
  lpQuoteDeltaToken: Decimal
  marketPriceId: Int
  positionId: Int
  quoteToken: Decimal
  tradeRatioD18: Decimal
  type: transaction_type_enum!
}

input TransactionListRelationFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

type TransactionMaxAggregate {
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal
  collateralTransferId: Int
  createdAt: DateTimeISO
  eventId: Int
  id: Int
  lpBaseDeltaToken: Decimal
  lpQuoteDeltaToken: Decimal
  marketPriceId: Int
  positionId: Int
  quoteToken: Decimal
  tradeRatioD18: Decimal
  type: transaction_type_enum
}

input TransactionMaxOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  collateralTransferId: SortOrder
  createdAt: SortOrder
  eventId: SortOrder
  id: SortOrder
  lpBaseDeltaToken: SortOrder
  lpQuoteDeltaToken: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
  tradeRatioD18: SortOrder
  type: SortOrder
}

type TransactionMinAggregate {
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal
  collateralTransferId: Int
  createdAt: DateTimeISO
  eventId: Int
  id: Int
  lpBaseDeltaToken: Decimal
  lpQuoteDeltaToken: Decimal
  marketPriceId: Int
  positionId: Int
  quoteToken: Decimal
  tradeRatioD18: Decimal
  type: transaction_type_enum
}

input TransactionMinOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  collateralTransferId: SortOrder
  createdAt: SortOrder
  eventId: SortOrder
  id: SortOrder
  lpBaseDeltaToken: SortOrder
  lpQuoteDeltaToken: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
  tradeRatioD18: SortOrder
  type: SortOrder
}

input TransactionNullableRelationFilter {
  is: TransactionWhereInput
  isNot: TransactionWhereInput
}

input TransactionOrderByRelationAggregateInput {
  _count: SortOrder
}

input TransactionOrderByWithAggregationInput {
  _avg: TransactionAvgOrderByAggregateInput
  _count: TransactionCountOrderByAggregateInput
  _max: TransactionMaxOrderByAggregateInput
  _min: TransactionMinOrderByAggregateInput
  _sum: TransactionSumOrderByAggregateInput
  baseToken: SortOrderInput
  borrowedBaseToken: SortOrderInput
  borrowedQuoteToken: SortOrderInput
  collateral: SortOrder
  collateralTransferId: SortOrderInput
  createdAt: SortOrder
  eventId: SortOrderInput
  id: SortOrder
  lpBaseDeltaToken: SortOrderInput
  lpQuoteDeltaToken: SortOrderInput
  marketPriceId: SortOrderInput
  positionId: SortOrderInput
  quoteToken: SortOrderInput
  tradeRatioD18: SortOrderInput
  type: SortOrder
}

input TransactionOrderByWithRelationInput {
  baseToken: SortOrderInput
  borrowedBaseToken: SortOrderInput
  borrowedQuoteToken: SortOrderInput
  collateral: SortOrder
  collateralTransfer: CollateralTransferOrderByWithRelationInput
  collateralTransferId: SortOrderInput
  createdAt: SortOrder
  event: EventOrderByWithRelationInput
  eventId: SortOrderInput
  id: SortOrder
  lpBaseDeltaToken: SortOrderInput
  lpQuoteDeltaToken: SortOrderInput
  marketPrice: MarketPriceOrderByWithRelationInput
  marketPriceId: SortOrderInput
  position: PositionOrderByWithRelationInput
  positionId: SortOrderInput
  quoteToken: SortOrderInput
  tradeRatioD18: SortOrderInput
  type: SortOrder
}

enum TransactionScalarFieldEnum {
  baseToken
  borrowedBaseToken
  borrowedQuoteToken
  collateral
  collateralTransferId
  createdAt
  eventId
  id
  lpBaseDeltaToken
  lpQuoteDeltaToken
  marketPriceId
  positionId
  quoteToken
  tradeRatioD18
  type
}

input TransactionScalarWhereWithAggregatesInput {
  AND: [TransactionScalarWhereWithAggregatesInput!]
  NOT: [TransactionScalarWhereWithAggregatesInput!]
  OR: [TransactionScalarWhereWithAggregatesInput!]
  baseToken: DecimalNullableWithAggregatesFilter
  borrowedBaseToken: DecimalNullableWithAggregatesFilter
  borrowedQuoteToken: DecimalNullableWithAggregatesFilter
  collateral: DecimalWithAggregatesFilter
  collateralTransferId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  eventId: IntNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  lpBaseDeltaToken: DecimalNullableWithAggregatesFilter
  lpQuoteDeltaToken: DecimalNullableWithAggregatesFilter
  marketPriceId: IntNullableWithAggregatesFilter
  positionId: IntNullableWithAggregatesFilter
  quoteToken: DecimalNullableWithAggregatesFilter
  tradeRatioD18: DecimalNullableWithAggregatesFilter
  type: Enumtransaction_type_enumWithAggregatesFilter
}

type TransactionSumAggregate {
  baseToken: Decimal
  borrowedBaseToken: Decimal
  borrowedQuoteToken: Decimal
  collateral: Decimal
  collateralTransferId: Int
  eventId: Int
  id: Int
  lpBaseDeltaToken: Decimal
  lpQuoteDeltaToken: Decimal
  marketPriceId: Int
  positionId: Int
  quoteToken: Decimal
  tradeRatioD18: Decimal
}

input TransactionSumOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  collateralTransferId: SortOrder
  eventId: SortOrder
  id: SortOrder
  lpBaseDeltaToken: SortOrder
  lpQuoteDeltaToken: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
  tradeRatioD18: SortOrder
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  baseToken: DecimalNullableFilter
  borrowedBaseToken: DecimalNullableFilter
  borrowedQuoteToken: DecimalNullableFilter
  collateral: DecimalFilter
  collateralTransfer: CollateralTransferNullableRelationFilter
  collateralTransferId: IntNullableFilter
  createdAt: DateTimeFilter
  event: EventNullableRelationFilter
  eventId: IntNullableFilter
  id: IntFilter
  lpBaseDeltaToken: DecimalNullableFilter
  lpQuoteDeltaToken: DecimalNullableFilter
  marketPrice: MarketPriceNullableRelationFilter
  marketPriceId: IntNullableFilter
  position: PositionNullableRelationFilter
  positionId: IntNullableFilter
  quoteToken: DecimalNullableFilter
  tradeRatioD18: DecimalNullableFilter
  type: Enumtransaction_type_enumFilter
}

input TransactionWhereUniqueInput {
  AND: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  baseToken: DecimalNullableFilter
  borrowedBaseToken: DecimalNullableFilter
  borrowedQuoteToken: DecimalNullableFilter
  collateral: DecimalFilter
  collateralTransfer: CollateralTransferNullableRelationFilter
  collateralTransferId: Int
  createdAt: DateTimeFilter
  event: EventNullableRelationFilter
  eventId: Int
  id: Int
  lpBaseDeltaToken: DecimalNullableFilter
  lpQuoteDeltaToken: DecimalNullableFilter
  marketPrice: MarketPriceNullableRelationFilter
  marketPriceId: Int
  position: PositionNullableRelationFilter
  positionId: IntNullableFilter
  quoteToken: DecimalNullableFilter
  tradeRatioD18: DecimalNullableFilter
  type: Enumtransaction_type_enumFilter
}

enum transaction_type_enum {
  addLiquidity
  long
  removeLiquidity
  settledPosition
  short
}